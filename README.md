# Corda OSGi Node Eperiment

## Abstract

The experiment combines an OSGi framework wrapper with an OSGi bundle providing the Corda node functionalities.
The `osgi-wrap` module produces an executable jar launching the OSGi framework,
then it installs and activate in the framework the needed bundles to finally install and activate the
Corda node bundle generated by the `corda-node` module.
    
This document shows how to develop an IDEA project, based on this code as template, that is an OSGi bundle however
allows developers to code in Kotlin using the libraries and the conventions we use in R3 to develop Corda.   

## OSGi framework layers and required bundles.

The wrapper deploys the bundles corda nodess needs, before to activate the node.
1. Logging service (via logback).
2. Kotlin.
3. Quartz fibers? (corda:core)

The bundles required before node activations are.

| JAR                           | Gradle coordinates                             |
|:------------------------------|:-----------------------------------------------|
| kotlin-osgi-bundle-1.4.0.jar  | org.jetbrains.kotlin:kotlin-osgi-bundle:1.4.10 |
| logback-classic-1.2.3.jar     | ch.qos.logback:logback-classic:1.2.3           |
| logback-core-1.2.3.jar        | ch.qos.logback:logback-core:1.2.3              |
| slf4j-api-1.7.30.jar          | org.slf4j:slf4j-api:1.7.30                     | 

### Notes

*These are Luca Debiasi's personal note during the development of the OSGi Corda Node experiment.* 

#### Logging

OSGi framework provides logging services exposed to the code through SLF4J.
In Corda 4 SLF4J is configured by code in NodeStartup.kt: these operations should be done through the OSGi framework.
Why custom logging settings are done in Corda 4.7, is something I need to discuss.  

### Service Sequence

The NodeStartup constructor is irrelevant.
ClearNewtorkCackeCli
GenerateNodeInfoCli
GenerateRpcSslCertsCli
InitialRegistrationCli has to be omitted: registration can happens any time when the node started in 5.
ValidateConfigurationCli()
RunMigrationScriptsCli
SynchroniseSchemasCli

Ignore additionalSubCommands in this experiment.
Ignore InstallShellExtensionsParser and ShellExtensionsGenerator.

1. Check for supported Java version.
Should be irrelevant because enforced by the framework. 

2. We do the single node check before we initialise logging so that in case of a double-node start it
doesn't mess with the running node's logs.
if (!isNodeRunningAt(cmdLineOptions.baseDirectory)) return ExitCodes.FAILURE
I need to discuss this: if the node is on the OSGi framework, it should be activated once.
**OSGi framework enforces only one bundle instance is active at the same time**

3. Register all cryptography [Provider]s.
IMPLEMENT Crypto.registerProviders()!

4. Print banner and basic node info.
NodeStartup.getVersionInfo() and CordaVersion use Manifests.read to load Corda* properties from
 META-INF/MANIFEST.MF.
drawBanner(versionInfo)
Node.printBasicNodeInfo(LOGS_CAN_BE_FOUND_IN_STRING, System.getProperty("log-path")) 

5. Load and validate node configuration.

6. Check if we can access the certificates directory

7. Configuring special serialisation requirements, i.e., bft-smart relies on Java serialization.

8. Any actions required before starting up the Corda network layer.

9. Log startup info.

10. Start node: create the node, check for other command-line options, add extra logging etc.
startup.startNode(node, startupTime)
createNode happens now.


 